<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Carte de Prospection - Mansion Bordeaux</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />

  <style>
    /* --- RESET & BASE --- */
    body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f5f5f5; color: #333; overflow: hidden; }
    * { box-sizing: border-box; }

    /* --- LAYOUT --- */
    header {
      background: #fff; padding: 10px 15px; border-bottom: 1px solid #ddd;
      display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px; z-index: 1000; position: relative;
    }
    .brand { font-weight: 700; font-size: 15px; }
    
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    select, button { font-size: 13px; padding: 6px 10px; border-radius: 6px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button.primary { background: #000; color: #fff; border: 1px solid #000; }
    button.accent { background: #0066cc; color: #fff; border: none; }
    button:active { transform: translateY(1px); }

    /* --- DASHBOARD (Stats & Tourn√©e) --- */
    #dashboard {
      background: #fff; border-bottom: 1px solid #ddd; padding: 10px 15px;
      max-height: 30vh; overflow-y: auto; font-size: 13px; display: flex; flex-direction: column; gap: 8px;
    }
    .stats-row { display: flex; gap: 15px; flex-wrap: wrap; color: #555; font-size: 12px; align-items: center; }
    .stat-item strong { color: #000; }
    
    .tour-panel { display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-start; background: #f9f9f9; padding: 10px; border-radius: 6px; border: 1px solid #eee; }
    .input-group { display: flex; flex-direction: column; gap: 4px; flex: 1; min-width: 120px; }
    .input-group label { font-size: 11px; font-weight: 600; color: #666; }
    .input-group input, .input-group textarea { padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; }
    .input-group textarea { resize: vertical; min-height: 32px; }

    /* --- CARTE --- */
    #map { width: 100%; height: calc(100vh - 180px); background: #e5e5e5; }
    
    /* --- LOADERS & FEEDBACK --- */
    #loadingOverlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255,255,255,0.95); z-index: 9999;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; padding: 20px;
    }
    .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #000; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    
    #statusMessage { color: green; font-weight: 600; font-size: 12px; margin-left: 10px; opacity: 0; transition: opacity 0.5s; }
    
    /* --- LEAFLET CUSTOM --- */
    .leaflet-popup-content { font-size: 13px; line-height: 1.4; }
    .popup-btn { width: 100%; margin-top: 8px; padding: 8px; background: #2ecc71; color: white; border: none; border-radius: 4px; cursor: pointer; }

    @media (max-width: 600px) {
      header { flex-direction: column; align-items: stretch; }
      .controls { justify-content: space-between; }
      #map { height: calc(100vh - 240px); }
    }
  </style>
</head>
<body>

  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingText">Initialisation de la carte Mansion...</div>
  </div>

  <header>
    <div class="brand">Mansion Bordeaux <span style="font-weight:400; color:#666;">| Prospection</span></div>
    <div class="controls">
      <select id="negociateurSelect">
        <option value="Alexis">Alexis (Nord-Ouest)</option>
        <option value="Nicolas">Nicolas (Nord-Est)</option>
        <option value="Thibault">Thibault (Sud-Ouest)</option>
        <option value="Laurent">Laurent (Sud-Est)</option>
      </select>
      <button id="gpsBtn" class="accent">üìç GPS</button>
      <button id="centerZoneBtn">Mon Secteur</button>
    </div>
  </header>

  <div id="dashboard">
    <div class="stats-row">
      <span class="stat-item">Tourn√©e en cours : <strong id="timerDisplay">00:00:00</strong></span>
      <span class="stat-item">Couverture secteur : <strong id="coverageDisplay">--%</strong></span>
      <span id="statusMessage"></span>
    </div>

    <div class="tour-panel">
      <div class="input-group">
        <label>Flyers</label>
        <input type="number" id="flyersInput" placeholder="150" />
      </div>
      <div class="input-group" style="flex: 2;">
        <label>Rapport / Notes</label>
        <textarea id="reportInput" placeholder="R.A.S ou adresse contact√©e..."></textarea>
      </div>
      <div style="display:flex; flex-direction:column; gap:5px; margin-top: auto;">
        <button id="toggleTourBtn" class="primary">‚ñ∂ D√©marrer</button>
        <button id="saveTourBtn" style="background:#eee; color:#333; border:1px solid #ccc;" disabled>üíæ Enregistrer</button>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
    /* =========================================
       1. CONFIGURATION & INITIALISATION
       ========================================= */
    
    // üîë CL√âS SUPABASE MISES √Ä JOUR (Fournies par l'utilisateur) üîë
    const SUPABASE_URL = "https://wqujtckrvdhrwknplumq.supabase.co"; 
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndxdWp0Y2tydmRocndrbnBsdW1xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxMjcwOTQsImV4cCI6MjA3ODcwMzA5NH0.btJD5-yD_zRJ9niEvwYEF46iB18OJo8nNXHRTbc8opI";

    // Initialisation Supabase
    let supabaseClient;
    try {
      const { createClient } = supabase;
      supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    } catch (e) {
      alert("Erreur config Supabase. V√©rifiez les cl√©s.");
    }

    // Configuration de la zone (Saint-Andr√©-de-Cubzac)
    const BBOX = "44.985,-0.46,45.003,-0.43"; // sud,ouest,nord,est pour Overpass

    // D√©finition des secteurs (Polygones simplifi√©s pour la d√©mo, mais robustes avec Turf)
    const ZONES = [
      {
        id: 1, negociateur: "Alexis", color: "#e74c3c",
        poly: [[-0.46, 45.003], [-0.445, 45.003], [-0.445, 44.994], [-0.46, 44.994], [-0.46, 45.003]] // GeoJSON format: [lng, lat]
      },
      {
        id: 2, negociateur: "Nicolas", color: "#3498db",
        poly: [[-0.445, 45.003], [-0.43, 45.003], [-0.43, 44.994], [-0.445, 44.994], [-0.445, 45.003]]
      },
      {
        id: 3, negociateur: "Thibault", color: "#f1c40f",
        poly: [[-0.46, 44.994], [-0.445, 44.994], [-0.445, 44.985], [-0.46, 44.985], [-0.46, 44.994]]
      },
      {
        id: 4, negociateur: "Laurent", color: "#9b59b6",
        poly: [[-0.445, 44.994], [-0.43, 44.994], [-0.43, 44.985], [-0.445, 44.985], [-0.445, 44.994]]
      }
    ];

    // √âtat Global
    const state = {
      negociateur: "Alexis",
      streets: {}, // Stocke les donn√©es des rues { nom: { layer, date, nego } }
      tourRunning: false,
      startTime: null,
      timerInterval: null,
      gpsWatch: null,
      userMarker: null
    };

    // √âl√©ments DOM
    const ui = {
      loader: document.getElementById('loadingOverlay'),
      loadText: document.getElementById('loadingText'),
      negociateurSelect: document.getElementById('negociateurSelect'),
      flyers: document.getElementById('flyersInput'),
      report: document.getElementById('reportInput'),
      toggleBtn: document.getElementById('toggleTourBtn'),
      saveBtn: document.getElementById('saveTourBtn'),
      timer: document.getElementById('timerDisplay'),
      coverage: document.getElementById('coverageDisplay'),
      status: document.getElementById('statusMessage'),
      gpsBtn: document.getElementById('gpsBtn'),
      // LIGNE CRITIQUE AJOUT√âE :
      centerZoneBtn: document.getElementById('centerZoneBtn') 
    };

    // Carte Leaflet
    const map = L.map('map', { zoomControl: false }).setView([44.994, -0.445], 14);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap',
      maxZoom: 19
    }).addTo(map);
    L.control.zoom({ position: 'bottomright' }).addTo(map);

    /* =========================================
       2. LOGIQUE M√âTIER
       ========================================= */

    // Calcul de l'√©tat d'une rue (Couleur)
    function getStreetColor(lastPassageDate) {
      if (!lastPassageDate) return "#95a5a6"; // Gris (Jamais fait)
      const diffTime = Math.abs(new Date() - new Date(lastPassageDate));
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 

      if (diffDays <= 20) return "#2ecc71"; // Vert (Fait r√©cemment)
      if (diffDays <= 45) return "#f39c12"; // Orange (√Ä refaire bient√¥t)
      return "#e74c3c"; // Rouge (√Ä refaire urgence)
    }

    // Chargement des donn√©es (Overpass + Supabase)
    async function initApp() {
      try {
        ui.loadText.textContent = "R√©cup√©ration de l'historique Supabase...";
        
        // 1. Charger l'historique des passages
        const { data: historyData, error } = await supabaseClient
          .from('street_passages')
          .select('street_name, passage_date, negociateur')
          .order('passage_date', { ascending: true }); // On prend tout pour construire l'√©tat

        const historyMap = {};
        if (historyData) {
          historyData.forEach(row => {
            // On garde le plus r√©cent
            historyMap[row.street_name] = { date: row.passage_date, nego: row.negociateur };
          });
        }

        ui.loadText.textContent = "T√©l√©chargement de la cartographie (OSM)...";

        // 2. Charger les rues depuis Overpass API
        const query = `[out:json][timeout:25];(way["highway"]~"residential|living_street|unclassified|tertiary"(${BBOX}););out geom;`;
        const response = await fetch("https://overpass-api.de/api/interpreter", {
          method: "POST", body: query
        });
        
        if (!response.ok) throw new Error("Overpass API indisponible");
        const osmData = await response.json();

        ui.loadText.textContent = "Construction de la carte...";

        // 3. Dessiner les rues
        osmData.elements.forEach(el => {
          if (el.type === 'way' && el.tags && el.tags.name) {
            const name = el.tags.name;
            const coords = el.geometry.map(pt => [pt.lat, pt.lon]); // LatLng pour Leaflet
            
            // D√©terminer le secteur avec Turf
            // On convertit en GeoJSON LineString pour Turf
            const lineGeoJSON = turf.lineString(el.geometry.map(pt => [pt.lon, pt.lat])); 
            const center = turf.center(lineGeoJSON);
            
            let zoneId = null;
            // V√©rifier dans quel polygone se trouve le centre de la rue
            for (let z of ZONES) {
              const polyGeoJSON = turf.polygon([z.poly]);
              if (turf.booleanPointInPolygon(center, polyGeoJSON)) {
                zoneId = z.id;
                break;
              }
            }

            // R√©cup√©rer l'historique
            const hist = historyMap[name] || { date: null, nego: null };
            const color = getStreetColor(hist.date);

            // Cr√©er la ligne Leaflet
            // Ligne √©paisse invisible pour faciliter le clic sur mobile
            L.polyline(coords, { color: 'transparent', weight: 20, opacity: 0 }).addTo(map)
              .on('click', (e) => openStreetPopup(e, name, zoneId));
            
            // Ligne visible
            const visibleLine = L.polyline(coords, { 
              color: color, weight: 4, opacity: 0.8, className: 'street-line' 
            }).addTo(map);

            // Stocker dans l'√©tat
            state.streets[name] = {
              layer: visibleLine,
              zoneId: zoneId,
              lastPassage: hist.date,
              lastNego: hist.nego
            };
          }
        });

        // 4. Dessiner les zones (contour subtil)
        ZONES.forEach(z => {
          // Inverser pour Leaflet [lat, lng]
          const leafPoly = z.poly.map(p => [p[1], p[0]]);
          L.polygon(leafPoly, { 
            color: z.color, fill: true, fillOpacity: 0.05, weight: 1, dashArray: '5, 5' 
          }).addTo(map);
        });

        updateInterface();
        // LIGNE DE D√âSACTIVATION DU LOADER (MAINTENANT S√õRE)
        ui.loader.style.display = 'none';

      } catch (err) {
        console.error(err);
        ui.loadText.textContent = "Erreur : " + err.message;
        alert("Impossible de charger la carte. V√©rifiez votre connexion et les cl√©s Supabase.");
      }
    }

    // Popup Rue
    function openStreetPopup(e, name, zoneId) {
      const st = state.streets[name];
      const dateStr = st.lastPassage ? new Date(st.lastPassage).toLocaleDateString() : "Jamais";
      
      const content = `
        <strong>${name}</strong><br>
        <small>Secteur : ${zoneId ? "Zone " + zoneId : "Hors Zone"}</small><br>
        Dernier passage : ${dateStr} (${st.lastNego || "-"})<br>
        <button class="popup-btn" onclick="markStreetAsDone('${name.replace(/'/g, "\\'")}')">
          ‚úÖ Marquer fait (Aujourd'hui)
        </button>
      `;
      
      L.popup()
        .setLatLng(e.latlng)
        .setContent(content)
        .openOn(map);
    }

    // Action : Marquer rue faite
    window.markStreetAsDone = async function(name) {
      const today = new Date().toISOString().split('T')[0];
      
      // 1. Update Visuel imm√©diat (Optimistic UI)
      const st = state.streets[name];
      if (st && st.layer) {
        st.layer.setStyle({ color: '#2ecc71' }); // Vert
        st.lastPassage = today;
        st.lastNego = state.negociateur;
      }
      map.closePopup();
      updateCoverage();

      // 2. Envoi Supabase
      const { error } = await supabaseClient.from('street_passages').insert({
        negociateur: state.negociateur,
        street_name: name,
        passage_date: today,
        zone_id: st.zoneId
      });

      if (error) {
        alert("Erreur de sauvegarde !");
        console.error(error);
        // Revert color si erreur (optionnel)
      }
    };

    /* =========================================
       3. GESTION TOURNEE & UI
       ========================================= */

    function updateInterface() {
      // Filtrer l'opacit√© des rues selon le n√©gociateur s√©lectionn√©
      const currentZoneId = ZONES.find(z => z.negociateur === state.negociateur)?.id;
      
      Object.values(state.streets).forEach(st => {
        if (st.zoneId === currentZoneId) {
          st.layer.setStyle({ opacity: 1, weight: 4 });
        } else {
          st.layer.setStyle({ opacity: 0.2, weight: 2 });
        }
      });
      updateCoverage();
    }

    function updateCoverage() {
      const currentZoneId = ZONES.find(z => z.negociateur === state.negociateur)?.id;
      const streetsInZone = Object.values(state.streets).filter(s => s.zoneId === currentZoneId);
      
      if (streetsInZone.length === 0) {
        ui.coverage.innerText = "N/A";
        return;
      }

      // Rues faites dans les 20 derniers jours
      const now = new Date();
      const doneCount = streetsInZone.filter(s => {
        if (!s.lastPassage) return false;
        const d = new Date(s.lastPassage);
        const diff = (now - d) / (1000 * 3600 * 24);
        return diff <= 20;
      }).length;

      const pct = Math.round((doneCount / streetsInZone.length) * 100);
      ui.coverage.innerText = `${doneCount}/${streetsInZone.length} (${pct}%)`;
    }

    // Timer
    function toggleTour() {
      if (state.tourRunning) {
        // Arr√™t
        clearInterval(state.timerInterval);
        state.tourRunning = false;
        ui.toggleBtn.textContent = "‚ñ∂ D√©marrer";
        ui.toggleBtn.classList.remove('accent');
        ui.toggleBtn.classList.add('primary');
        ui.saveBtn.disabled = false;
        ui.saveBtn.style.background = "#000";
        ui.saveBtn.style.color = "#fff";
      } else {
        // D√©marrage
        state.startTime = Date.now();
        state.tourRunning = true;
        ui.toggleBtn.textContent = "‚è∏ Pause";
        ui.toggleBtn.classList.remove('primary');
        ui.toggleBtn.classList.add('accent');
        ui.saveBtn.disabled = true;
        ui.saveBtn.style.background = "#eee";
        ui.saveBtn.style.color = "#333";
        
        state.timerInterval = setInterval(() => {
          const diff = Math.floor((Date.now() - state.startTime) / 1000);
          const h = String(Math.floor(diff / 3600)).padStart(2,'0');
          const m = String(Math.floor((diff % 3600) / 60)).padStart(2,'0');
          const s = String(diff % 60).padStart(2,'0');
          ui.timer.textContent = `${h}:${m}:${s}`;
        }, 1000);
      }
    }

    async function saveTour() {
      ui.saveBtn.textContent = "Enregistrement...";
      
      const durationSec = Math.floor((Date.now() - state.startTime) / 1000);

      const { error } = await supabaseClient.from('tours').insert({
        negociateur: state.negociateur,
        date: new Date().toISOString().split('T')[0],
        secteur_id: ZONES.find(z => z.negociateur === state.negociateur)?.id,
        flyers: parseInt(ui.flyers.value) || 0,
        notes: "",
        report: ui.report.value,
        duration_sec: durationSec // La dur√©e est correctement calcul√©e ici
      });

      if (!error) {
        showStatus("Sauvegard√© !");
        ui.flyers.value = "";
        ui.report.value = "";
        ui.timer.textContent = "00:00:00";
        state.startTime = null; // R√©initialisation
      } else {
        alert("Erreur sauvegarde tourn√©e");
      }
      ui.saveBtn.textContent = "üíæ Enregistrer";
    }

    function showStatus(msg) {
      ui.status.textContent = msg;
      ui.status.style.opacity = 1;
      setTimeout(() => ui.status.style.opacity = 0, 3000);
    }

    /* =========================================
       4. GEOLOCALISATION
       ========================================= */
    
    function toggleGPS() {
      if (state.gpsWatch) {
        navigator.geolocation.clearWatch(state.gpsWatch);
        state.gpsWatch = null;
        if (state.userMarker) map.removeLayer(state.userMarker);
        ui.gpsBtn.style.background = "#0066cc"; // bleu
        ui.gpsBtn.textContent = "üìç GPS";
      } else {
        if (!navigator.geolocation) return alert("GPS non support√©");
        
        ui.gpsBtn.style.background = "#e74c3c"; // rouge (pour arr√™ter)
        ui.gpsBtn.textContent = "üõë Arr√™t GPS";
        
        state.gpsWatch = navigator.geolocation.watchPosition(pos => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          const acc = pos.coords.accuracy;

          if (!state.userMarker) {
            state.userMarker = L.circleMarker([lat, lng], { radius: 8, color: 'white', fillColor: '#2980b9', fillOpacity: 1 }).addTo(map);
          } else {
            state.userMarker.setLatLng([lat, lng]);
          }
          
          // Centrer uniquement au premier fix ou si on demande
          // map.setView([lat, lng]); 
        }, err => {
          console.error(err);
          toggleGPS(); // D√©sactiver si erreur
          alert("Acc√®s GPS refus√© ou impossible");
        }, { enableHighAccuracy: true });
      }
    }

    /* =========================================
       LISTENERS
       ========================================= */
    
    ui.negociateurSelect.addEventListener('change', (e) => {
      state.negociateur = e.target.value;
      updateInterface();
    });

    ui.toggleBtn.addEventListener('click', toggleTour);
    ui.saveBtn.addEventListener('click', saveTour);
    ui.gpsBtn.addEventListener('click', toggleGPS);
    
    ui.centerZoneBtn.addEventListener('click', () => {
       const zone = ZONES.find(z => z.negociateur === state.negociateur);
       if (zone) {
         const poly = L.polygon(zone.poly.map(p => [p[1], p[0]]));
         map.fitBounds(poly.getBounds());
       }
    });

    // Lancement
    initApp();

  </script>
</body>
</html>
