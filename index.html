<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Carte de prospection - Mansion Bordeaux</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    header {
      padding: 8px 15px;
      font-size: 16px;
      font-weight: 600;
      border-bottom: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    #map {
      width: 100%;
      height: calc(100vh - 130px); /* place pour le panneau de tourn√©e */
    }
    .zone-info {
      font-size: 14px;
      line-height: 1.4;
    }
    .btn {
      display: inline-block;
      margin-top: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 13px;
    }
    .btn-primary {
      background: #000;
      color: #fff;
    }
    .negociateur-select {
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .negociateur-select select {
      padding: 4px 6px;
      font-size: 14px;
    }
    .btn-header {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      background: #000;
      color: #fff;
      white-space: nowrap;
    }

    /* Panneau de tourn√©e */
    #tourPanel {
      padding: 8px 15px;
      border-bottom: 1px solid #ddd;
      font-size: 13px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      align-items: flex-start;
    }
    #tourPanel label {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    #tourPanel input[type="number"],
    #tourPanel input[type="text"],
    #tourPanel textarea {
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      min-width: 120px;
    }
    #tourPanel textarea {
      min-width: 260px;
      min-height: 40px;
      resize: vertical;
    }
    #tourPanel-title {
      font-weight: 600;
      margin-right: 10px;
      white-space: nowrap;
    }
    #saveStatus {
      font-size: 12px;
      color: #388e3c;
      min-width: 160px;
    }
    #saveTourBtn, #toggleTourBtn {
      padding: 6px 10px;
      font-size: 13px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #000;
      color: #fff;
      white-space: nowrap;
    }
    #coverageInfo, #timerDisplay {
      font-size: 12px;
      white-space: nowrap;
    }

    @media (max-width: 768px) {
      #map {
        height: calc(100vh - 160px);
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      Carte de prospection ‚Äì Mansion Bordeaux (Saint-Andr√©-de-Cubzac)
    </div>
    <div class="negociateur-select">
      N√©gociateur :
      <select id="negociateurSelect">
        <option value="Alexis">Alexis</option>
        <option value="Nicolas">Nicolas</option>
        <option value="Thibault">Thibault</option>
        <option value="Laurent">Laurent</option>
      </select>
      <button id="mySectorBtn" class="btn-header">Mon secteur</button>
      <button id="gpsToggleBtn" class="btn-header">Activer GPS</button>
      <button id="gpsCenterBtn" class="btn-header">Me centrer</button>
    </div>
  </header>

  <!-- Panneau de tourn√©e -->
  <div id="tourPanel">
    <span id="tourPanel-title">Tourn√©e de <span id="currentNegociateurLabel">Alexis</span></span>

    <label>
      Prospectus distribu√©s
      <input type="number" id="flyersInput" min="0" placeholder="ex : 120" />
    </label>

    <label>
      Rencontres / notes rapides
      <input type="text" id="notesInput" placeholder="ex : 4 contacts int√©ress√©s" />
    </label>

    <label>
      D√©tails & projets de vente
      <textarea id="reportInput" placeholder="ex : Mme X envisage de vendre au printemps, rappeler en f√©vrier."></textarea>
    </label>

    <button id="saveTourBtn">Enregistrer la tourn√©e</button>

    <button id="toggleTourBtn">D√©marrer la tourn√©e</button>
    <span id="timerDisplay">Dur√©e : 00:00:00</span>

    <span id="coverageInfo">Couverture : ‚Äî</span>
    <span id="saveStatus"></span>
  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ---------- CONFIG GLOBALE ----------

    let currentNegociateur = "Alexis";
    const negociateurSelect = document.getElementById("negociateurSelect");
    const currentNegociateurLabel = document.getElementById("currentNegociateurLabel");
    const mySectorBtn = document.getElementById("mySectorBtn");
    const gpsToggleBtn = document.getElementById("gpsToggleBtn");
    const gpsCenterBtn = document.getElementById("gpsCenterBtn");

    // Panneau de tourn√©e
    const flyersInput = document.getElementById("flyersInput");
    const notesInput = document.getElementById("notesInput");
    const reportInput = document.getElementById("reportInput");
    const saveTourBtn = document.getElementById("saveTourBtn");
    const saveStatus = document.getElementById("saveStatus");
    const coverageInfo = document.getElementById("coverageInfo");
    const toggleTourBtn = document.getElementById("toggleTourBtn");
    const timerDisplay = document.getElementById("timerDisplay");

    const toursData = {}; // { nego: {flyers, notes, report, lastUpdate, durationSec} }

    // Timer
    let tourRunning = false;
    let tourStartTime = null;
    let tourTimerInterval = null;
    const lastTourDurationSecByNego = {};

    // Geoloc
    let gpsEnabled = false;
    let gpsWatchId = null;
    let userMarker = null;
    let userAccuracyCircle = null;
    let userHasBeenCentered = false;

    negociateurSelect.addEventListener("change", (e) => {
      stopCurrentTour();
      currentNegociateur = e.target.value;
      currentNegociateurLabel.textContent = currentNegociateur;
      loadTourDataFor(currentNegociateur);
      focusOnNegotiator(currentNegociateur);
      updateCoverageForCurrentNegociateur();
      updateTimerDisplay();
    });

    mySectorBtn.addEventListener("click", () => {
      focusOnNegotiator(currentNegociateur);
    });

    saveTourBtn.addEventListener("click", () => {
      saveCurrentTour();
    });

    toggleTourBtn.addEventListener("click", () => {
      if (!tourRunning) {
        tourRunning = true;
        tourStartTime = Date.now();
        toggleTourBtn.textContent = "Arr√™ter la tourn√©e";
        tourTimerInterval = setInterval(updateTimerDisplay, 1000);
      } else {
        stopCurrentTour();
      }
      updateTimerDisplay();
    });

    gpsToggleBtn.addEventListener("click", () => {
      if (!gpsEnabled) {
        startGpsTracking();
      } else {
        stopGpsTracking();
      }
    });

    gpsCenterBtn.addEventListener("click", () => {
      centerOnUser();
    });

    function stopCurrentTour() {
      if (!tourRunning || !tourStartTime) return;
      const elapsed = Math.floor((Date.now() - tourStartTime) / 1000);
      const prev = lastTourDurationSecByNego[currentNegociateur] || 0;
      lastTourDurationSecByNego[currentNegociateur] = prev + elapsed;
      tourRunning = false;
      tourStartTime = null;
      clearInterval(tourTimerInterval);
      toggleTourBtn.textContent = "D√©marrer la tourn√©e";
    }

    function formatDuration(sec) {
      const h = String(Math.floor(sec / 3600)).padStart(2, "0");
      const m = String(Math.floor((sec % 3600) / 60)).padStart(2, "0");
      const s = String(sec % 60).padStart(2, "0");
      return `${h}:${m}:${s}`;
    }

    function updateTimerDisplay() {
      const base = lastTourDurationSecByNego[currentNegociateur] || 0;
      let total = base;
      if (tourRunning && tourStartTime) {
        total += Math.floor((Date.now() - tourStartTime) / 1000);
      }
      timerDisplay.textContent = "Dur√©e : " + formatDuration(total);
    }

    function saveCurrentTour() {
      stopCurrentTour();
      updateTimerDisplay();

      const flyers = parseInt(flyersInput.value, 10) || 0;
      const notes = (notesInput.value || "").trim();
      const report = (reportInput.value || "").trim();
      const now = new Date();
      const durationSec = lastTourDurationSecByNego[currentNegociateur] || 0;

      toursData[currentNegociateur] = {
        flyers,
        notes,
        report,
        lastUpdate: now.toISOString(),
        durationSec
      };

      saveStatus.textContent = `Tourn√©e enregistr√©e pour ${currentNegociateur} (${formatDuration(durationSec)})`;
      setTimeout(() => {
        saveStatus.textContent = "";
      }, 4000);
    }

    function loadTourDataFor(nego) {
      const data = toursData[nego];
      if (!data) {
        flyersInput.value = "";
        notesInput.value = "";
        reportInput.value = "";
        lastTourDurationSecByNego[nego] = lastTourDurationSecByNego[nego] || 0;
        saveStatus.textContent = "";
        return;
      }
      flyersInput.value = data.flyers ?? "";
      notesInput.value = data.notes ?? "";
      reportInput.value = data.report ?? "";
      lastTourDurationSecByNego[nego] = data.durationSec || 0;
      saveStatus.textContent = "";
    }

    // BBox de Saint-Andr√© (l√©g√®rement √©largie)
    const BBOX = {
      south: 44.985,
      west: -0.46,
      north: 45.003,
      east: -0.43
    };

    // ---------- INIT CARTE ----------

    const map = L.map("map").setView([44.994, -0.443], 14);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    // Popup Street View sur appui long / clic droit
    map.on("contextmenu", function(e) {
      const lat = e.latlng.lat.toFixed(6);
      const lng = e.latlng.lng.toFixed(6);
      const html = `
        <div class="zone-info">
          <strong>Street View & coordonn√©es</strong><br/>
          Lat : ${lat}<br/>
          Lng : ${lng}<br/>
          <button class="btn btn-primary" onclick="openStreetView(${lat}, ${lng})">
            Ouvrir Street View ici
          </button>
        </div>
      `;
      L.popup()
        .setLatLng(e.latlng)
        .setContent(html)
        .openOn(map);
    });

    window.openStreetView = function(lat, lng) {
      const url = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat},${lng}`;
      window.open(url, "_blank");
    };

    // ---------- SECTEURS (initialement rectangles, puis adapt√©s aux rues) ----------

    const zones = [
      {
        id: 1,
        nom: "Secteur 1 ‚Äì Alexis ‚Äì Nord-Ouest",
        negociateur: "Alexis",
        bbox: { minLat: 44.994, maxLat: 45.003, minLng: -0.46, maxLng: -0.445 },
        polygonCoords: [
          [45.003, -0.46],
          [45.003, -0.445],
          [44.994, -0.445],
          [44.994, -0.46]
        ],
        points: []
      },
      {
        id: 2,
        nom: "Secteur 2 ‚Äì Nicolas ‚Äì Nord-Est",
        negociateur: "Nicolas",
        bbox: { minLat: 44.994, maxLat: 45.003, minLng: -0.445, maxLng: -0.43 },
        polygonCoords: [
          [45.003, -0.445],
          [45.003, -0.43],
          [44.994, -0.43],
          [44.994, -0.445]
        ],
        points: []
      },
      {
        id: 3,
        nom: "Secteur 3 ‚Äì Thibault ‚Äì Sud-Ouest",
        negociateur: "Thibault",
        bbox: { minLat: 44.985, maxLat: 44.994, minLng: -0.46, maxLng: -0.445 },
        polygonCoords: [
          [44.994, -0.46],
          [44.994, -0.445],
          [44.985, -0.445],
          [44.985, -0.46]
        ],
        points: []
      },
      {
        id: 4,
        nom: "Secteur 4 ‚Äì Laurent ‚Äì Sud-Est",
        negociateur: "Laurent",
        bbox: { minLat: 44.985, maxLat: 44.994, minLng: -0.445, maxLng: -0.43 },
        polygonCoords: [
          [44.994, -0.445],
          [44.994, -0.43],
          [44.985, -0.43],
          [44.985, -0.445]
        ],
        points: []
      }
    ];

    const zoneLayers = {};
    const zoneStreetNames = {};
    zones.forEach(z => zoneStreetNames[z.id] = new Set());

    const negoToZoneId = {};
    zones.forEach(z => {
      if (z.negociateur) {
        negoToZoneId[z.negociateur] = z.id;
      }
    });

    const streetState = {};
    const streetLayers = {};
    let currentStreetForPopup = null;

    // ---------- ETATS / COULEURS ----------

    function getStreetEtat(state) {
      if (!state || !state.dernierPassage) return "afaire";
      const passageDate = new Date(state.dernierPassage);
      if (isNaN(passageDate)) return "afaire";
      const now = new Date();
      const diffDays = (now - passageDate) / (1000 * 60 * 60 * 24);
      if (diffDays <= 20) return "fait";
      return "arefaire";
    }

    function colorFromEtat(etat) {
      switch (etat) {
        case "fait":     return "#4caf50";
        case "arefaire": return "#ff9800";
        case "afaire":
        default:         return "#f44336";
      }
    }

    function calculEtatSecteur(zoneId) {
      const names = Array.from(zoneStreetNames[zoneId] || []);
      if (names.length === 0) return "afaire";
      let hasAfaire = false;
      let hasArefaire = false;
      names.forEach(name => {
        const st = streetState[name];
        const etat = getStreetEtat(st);
        if (etat === "afaire") hasAfaire = true;
        else if (etat === "arefaire") hasArefaire = true;
      });
      if (hasAfaire) return "afaire";
      if (hasArefaire) return "arefaire";
      return "fait";
    }

    function updateAllZonesVisual() {
      zones.forEach(zone => {
        const etat = calculEtatSecteur(zone.id);
        const poly = zoneLayers[zone.id];
        if (poly) {
          poly.setStyle({
            color: colorFromEtat(etat),
            weight: 2,
            fillOpacity: poly.options._hidden ? 0 : 0.15,
            opacity: poly.options._hidden ? 0 : 1
          });
        }
      });
      updateCoverageForCurrentNegociateur();
    }

    function updateCoverageForCurrentNegociateur() {
      const zoneId = negoToZoneId[currentNegociateur];
      if (!zoneId) {
        coverageInfo.textContent = "Couverture : ‚Äî";
        return;
      }
      const names = Array.from(zoneStreetNames[zoneId] || []);
      const total = names.length;
      if (total === 0) {
        coverageInfo.textContent = "Couverture : ‚Äî";
        return;
      }
      let done = 0;
      names.forEach(name => {
        const etat = getStreetEtat(streetState[name]);
        if (etat === "fait") done++;
      });
      const pct = Math.round((done * 100) / total);
      coverageInfo.textContent = `Couverture : ${done} / ${total} rue(s) ‚Äî ${pct}%`;
    }

    // ---------- UTILITAIRES ----------

    function computeCentroid(coords) {
      let lat = 0, lng = 0;
      coords.forEach(c => { lat += c[0]; lng += c[1]; });
      return [lat / coords.length, lng / coords.length];
    }

    function findZoneForPoint(lat, lng) {
      return zones.find(z =>
        lat >= z.bbox.minLat &&
        lat <= z.bbox.maxLat &&
        lng >= z.bbox.minLng &&
        lng <= z.bbox.maxLng
      );
    }

    function findZoneIdForStreet(name) {
      for (const zone of zones) {
        if (zoneStreetNames[zone.id].has(name)) return zone.id;
      }
      return null;
    }

    // Convex hull (contour des secteurs √† partir des rues)
    function cross(o, a, b) {
      const x1 = a[1] - o[1];
      const y1 = a[0] - o[0];
      const x2 = b[1] - o[1];
      const y2 = b[0] - o[0];
      return x1 * y2 - y1 * x2;
    }

    function buildHull(points) {
      if (!points || points.length < 3) return points || [];
      const pts = points.slice().sort((p1, p2) => {
        if (p1[1] === p2[1]) return p1[0] - p2[0]; // tri par lng puis lat
        return p1[1] - p2[1];
      });
      const lower = [];
      for (const p of pts) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
          lower.pop();
        }
        lower.push(p);
      }
      const upper = [];
      for (let i = pts.length - 1; i >= 0; i--) {
        const p = pts[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
          upper.pop();
        }
        upper.push(p);
      }
      upper.pop();
      lower.pop();
      return lower.concat(upper);
    }

    // ---------- HIGHLIGHT DES RUES PAR SECTEUR ----------

    function highlightZone(zoneId) {
      Object.entries(streetLayers).forEach(([name, layers]) => {
        const inZone = zoneStreetNames[zoneId]?.has(name);
        layers.forEach(layer => {
          layer.setStyle({
            opacity: inZone ? 0.9 : 0.15,
            weight: inZone ? 3 : 1.5
          });
        });
      });
    }

    // ---------- FILTRE / FOCUS PAR N√âGOCIATEUR ----------

    function focusOnNegotiator(nego) {
      const zoneId = negoToZoneId[nego];
      if (!zoneId) {
        Object.values(zoneLayers).forEach(poly => {
          poly.options._hidden = false;
          poly.setStyle({ opacity: 1, fillOpacity: 0.15 });
        });
        return;
      }

      zones.forEach(zone => {
        const poly = zoneLayers[zone.id];
        if (!poly) return;
        if (zone.id === zoneId) {
          poly.options._hidden = false;
          poly.setStyle({ opacity: 1, fillOpacity: 0.15 });
          map.fitBounds(poly.getBounds(), {
            maxZoom: 17,
            padding: [20, 20]
          });
        } else {
          poly.options._hidden = true;
          poly.setStyle({ opacity: 0, fillOpacity: 0 });
        }
      });

      highlightZone(zoneId);
    }

    // ---------- POPUP RUE ----------

    function openStreetPopup(name, latlng) {
      currentStreetForPopup = name;
      const state = streetState[name] || { dernierPassage: null, dernierNegociateur: null };
      const etat = getStreetEtat(state);
      let label;
      switch (etat) {
        case "fait":     label = "‚úÖ Fait (‚â§ 20 jours)"; break;
        case "arefaire": label = "üü† √Ä refaire (> 20 jours)"; break;
        default:         label = "üî¥ Pas fait"; break;
      }

      const html = `
        <div class="zone-info">
          <strong>${name}</strong><br/>
          √âtat : ${label}<br/>
          Dernier passage : ${state.dernierPassage || "Jamais"} (${state.dernierNegociateur || "‚Äî"})<br/>
          <button class="btn btn-primary" onclick="marquerRueFait()">
            Marquer cette rue comme faite aujourd'hui
          </button>
        </div>
      `;

      L.popup()
        .setLatLng(latlng)
        .setContent(html)
        .openOn(map);
    }

    // ---------- DESSIN DES SECTEURS (init) ----------

    zones.forEach(zone => {
      const polygon = L.polygon(zone.polygonCoords, {
        color: "#f44336",
        weight: 2,
        fillOpacity: 0.1
      }).addTo(map);

      zoneLayers[zone.id] = polygon;

      polygon.bindPopup(`
        <div class="zone-info">
          <strong>${zone.nom}</strong><br/>
          N√©gociateur principal : ${zone.negociateur}
        </div>
      `);

      polygon.on("click", () => {
        highlightZone(zone.id);
        map.fitBounds(polygon.getBounds(), {
          maxZoom: 17,
          padding: [20, 20]
        });
        polygon.openPopup();
      });
    });

    // ---------- CHARGEMENT DES RUES OSM (Overpass API) ----------

    const overpassQuery = `
      [out:json][timeout:25];
      (
        way["highway"]["name"](${BBOX.south},${BBOX.west},${BBOX.north},${BBOX.east});
      );
      out geom;
    `;

    fetch("https://overpass-api.de/api/interpreter", {
      method: "POST",
      body: overpassQuery
    })
      .then(res => res.json())
      .then(data => {
        if (!data.elements) return;

        data.elements
          .filter(el => el.type === "way" && el.tags && el.tags.name)
          .forEach(way => {
            const name = way.tags.name;
            const coords = way.geometry.map(pt => [pt.lat, pt.lon]);

            if (!streetState[name]) {
              streetState[name] = {
                dernierPassage: null,
                dernierNegociateur: null
              };
            }

            const etat = getStreetEtat(streetState[name]);
            const color = colorFromEtat(etat);

            const line = L.polyline(coords, {
              color: color,
              weight: 3,      // plus √©pais = plus cliquable sur mobile
              opacity: 0.7
            }).addTo(map);

            if (!streetLayers[name]) streetLayers[name] = [];
            streetLayers[name].push(line);

            const centroid = computeCentroid(coords);
            const zone = findZoneForPoint(centroid[0], centroid[1]);
            if (zone) {
              zoneStreetNames[zone.id].add(name);
              zone.points.push(...coords); // pour le contour du secteur
            }

            const midIdx = Math.floor(coords.length / 2);
            const midLatLng = coords[midIdx];

            const handleTap = (e) => {
              const latlng = e && e.latlng ? e.latlng : midLatLng;
              openStreetPopup(name, latlng);
              const zid = findZoneIdForStreet(name);
              if (zid) highlightZone(zid);
            };

            line.on("click", handleTap);
            line.on("tap", handleTap);
            line.on("touchstart", handleTap);
          });

        // Recalcule les polygones pour qu'ils √©pousent la forme des rues
        zones.forEach(zone => {
          if (zone.points && zone.points.length >= 3) {
            const hull = buildHull(zone.points);
            if (hull && hull.length >= 3) {
              zone.polygonCoords = hull;
              const poly = zoneLayers[zone.id];
              if (poly) {
                poly.setLatLngs(hull);
              }
            }
          }
        });

        updateAllZonesVisual();
        focusOnNegotiator(currentNegociateur);
        updateCoverageForCurrentNegociateur();
      })
      .catch(err => {
        console.error("Erreur Overpass:", err);
        alert("Impossible de charger les rues depuis OpenStreetMap (Overpass). V√©rifie la connexion internet.");
      });

    // ---------- MARQUER UNE RUE COMME FAITE ----------

    window.marquerRueFait = function () {
      if (!currentStreetForPopup) return;
      const name = currentStreetForPopup;
      const state = streetState[name] || { dernierPassage: null, dernierNegociateur: null };

      const aujourdHui = new Date().toISOString().slice(0, 10);
      state.dernierPassage = aujourdHui;
      state.dernierNegociateur = currentNegociateur;
      streetState[name] = state;

      const etat = getStreetEtat(state);
      const color = colorFromEtat(etat);
      (streetLayers[name] || []).forEach(line => {
        line.setStyle({
          color: color,
          opacity: 0.9,
          weight: 3.2
        });
      });

      updateAllZonesVisual();

      const layers = streetLayers[name] || [];
      if (layers.length > 0) {
        const latlng = layers[0].getCenter();
        openStreetPopup(name, latlng);
        const zid = findZoneIdForStreet(name);
        if (zid) highlightZone(zid);
      }
    };

    // ---------- GEOLOCALISATION ----------

    function startGpsTracking() {
      if (!navigator.geolocation) {
        alert("La g√©olocalisation n'est pas support√©e par ce navigateur.");
        return;
      }
      if (gpsEnabled) return;

      gpsEnabled = true;
      userHasBeenCentered = false;
      gpsToggleBtn.textContent = "Arr√™ter GPS";

      gpsWatchId = navigator.geolocation.watchPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          const acc = pos.coords.accuracy;

          const latlng = [lat, lng];

          if (!userMarker) {
            userMarker = L.marker(latlng).addTo(map);
          } else {
            userMarker.setLatLng(latlng);
          }

          if (!userAccuracyCircle) {
            userAccuracyCircle = L.circle(latlng, {
              radius: acc,
              weight: 1,
              opacity: 0.6,
              fillOpacity: 0.1
            }).addTo(map);
          } else {
            userAccuracyCircle.setLatLng(latlng);
            userAccuracyCircle.setRadius(acc);
          }

          if (!userHasBeenCentered) {
            map.setView(latlng, 17);
            userHasBeenCentered = true;
          }
        },
        (err) => {
          console.error("Erreur GPS:", err);
          alert("Impossible d'obtenir votre position (autorisation refus√©e ?).");
          stopGpsTracking();
        },
        {
          enableHighAccuracy: true,
          maximumAge: 30000,
          timeout: 20000
        }
      );
    }

    function stopGpsTracking() {
      if (!gpsEnabled) return;
      gpsEnabled = false;
      gpsToggleBtn.textContent = "Activer GPS";
      userHasBeenCentered = false;

      if (gpsWatchId !== null) {
        navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
      }
      if (userMarker) {
        map.removeLayer(userMarker);
        userMarker = null;
      }
      if (userAccuracyCircle) {
        map.removeLayer(userAccuracyCircle);
        userAccuracyCircle = null;
      }
    }

    function centerOnUser() {
      if (userMarker) {
        map.setView(userMarker.getLatLng(), 17);
      } else if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const latlng = [pos.coords.latitude, pos.coords.longitude];
            map.setView(latlng, 17);
          },
          (err) => {
            console.error("Erreur GPS (centrage):", err);
            alert("Impossible d'obtenir votre position pour vous centrer.");
          },
          { enableHighAccuracy: true, timeout: 20000 }
        );
      } else {
        alert("La g√©olocalisation n'est pas disponible sur ce navigateur.");
      }
    }

    // ---------- INIT UI ----------

    currentNegociateurLabel.textContent = currentNegociateur;
    loadTourDataFor(currentNegociateur);
    updateTimerDisplay();
  </script>
</body>
</html>
