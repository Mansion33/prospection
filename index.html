<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Carte Mansion - Prospection</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />

  <style>
    body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f5f5f5; overflow: hidden; }
    * { box-sizing: border-box; }

    /* Header & Controls */
    header { background: #fff; padding: 10px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; height: 60px; }
    .brand { font-weight: 700; font-size: 14px; }
    .controls { display: flex; gap: 6px; align-items: center; }
    select, button { padding: 5px 10px; border-radius: 4px; border: 1px solid #999; font-size: 12px; background: white; cursor: pointer; }
    button.primary { background: black; color: white; border-color: black; }
    button.accent { background: #0066cc; color: #fff; border-color: #0066cc; }
    button:active { transform: translateY(1px); }

    /* Dashboard */
    #dashboard { background: white; padding: 10px; font-size: 12px; height: 140px; border-bottom: 1px solid #ddd; display: flex; flex-direction: column; gap: 5px; }
    .stats { display: flex; justify-content: space-between; margin-bottom: 5px; font-weight: 600; color: #555; }
    .inputs { display: flex; gap: 5px; }
    .inputs input, .inputs textarea { flex: 1; padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; }
    #tourInfo { font-size: 11px; color: #555; margin-top: 2px; }

    /* Map */
    #map { width: 100%; height: calc(100vh - 200px); background: #e5e5e5; z-index: 1; }

    /* Loader */
    #loader {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: white; z-index: 9999; display: flex; justify-content: center; align-items: center;
      transition: opacity 0.5s;
    }
    .spinner { width: 40px; height: 40px; border: 4px solid #eee; border-top: 4px solid #000; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 10px auto; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .hidden { opacity: 0; pointer-events: none; }

    /* Popup */
    .popup-content { text-align: center; min-width: 160px; }
    .btn-popup { background: #2ecc71; color: #fff; border: none; padding: 8px; width: 100%; margin-top: 5px; cursor: pointer; border-radius: 4px; font-size: 12px; }
    .btn-popup.secondary { background: #34495e; }

    @media (max-width: 600px) {
      header { flex-direction: column; height: auto; gap: 6px; align-items: flex-start; }
      #map { height: calc(100vh - 230px); }
    }
  </style>
</head>
<body>

  <div id="loader">
    <div style="text-align:center">
      <div class="spinner"></div>
      <div>Chargement de la carte de prospection...</div>
      <small style="color:#999; margin-top:5px; display:block;">Si √ßa bloque, √ßa se fermera tout seul.</small>
    </div>
  </div>

  <header>
    <div class="brand">Mansion Prospection</div>
    <div class="controls">
      <select id="negociateur">
        <option value="Alexis">Alexis (NO)</option>
        <option value="Nicolas">Nicolas (NE)</option>
        <option value="Thibault">Thibault (SO)</option>
        <option value="Laurent">Laurent (SE)</option>
      </select>
      <button id="btnGps" class="accent">üìç GPS</button>
      <button id="btnLoad">‚ûï Rues</button>
    </div>
  </header>

  <div id="dashboard">
    <div class="stats">
      <span>‚è± Tourn√©e : <strong id="timer">00:00:00</strong></span>
      <span>üìä Couverture : <strong id="coverage">0% couverts</strong></span>
    </div>
    <div class="inputs">
      <input type="number" id="flyers" placeholder="Nb de flyers distribu√©s">
      <textarea id="notes" placeholder="Notes globales de la tourn√©e (facultatif)..."></textarea>
    </div>
    <div style="margin-top:5px; display:flex; gap:5px;">
      <button id="btnStart" class="primary" style="flex:1;">‚ñ∂ D√©marrer</button>
      <button id="btnSave" style="flex:1; background:#eee; color:#555;" disabled>‚úÖ Terminer & enregistrer</button>
    </div>
    <div id="tourInfo"></div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
    // --- S√©curit√© anti-chargement infini (fallback 2s) ---
    setTimeout(() => {
      const loader = document.getElementById('loader');
      if (loader && !loader.classList.contains('hidden')) {
        console.warn("For√ßage fermeture loader");
        loader.classList.add('hidden');
      }
    }, 2000);

    // --- Carte Leaflet ---
    const map = L.map('map').setView([44.996, -0.446], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap' }).addTo(map);

    // --- Secteurs (polygones) ---
    const ZONES = [
      { id:1, nego:"Alexis",  color:"#e74c3c", poly:[[-0.48,45.02],[-0.446,45.02],[-0.446,44.995],[-0.48,44.995]] },
      { id:2, nego:"Nicolas", color:"#3498db", poly:[[-0.446,45.02],[-0.41,45.02],[-0.41,44.995],[-0.446,44.995]] },
      { id:3, nego:"Thibault",color:"#f1c40f", poly:[[-0.48,44.995],[-0.446,44.995],[-0.446,44.96],[-0.48,44.96]] },
      { id:4, nego:"Laurent", color:"#9b59b6", poly:[[-0.446,44.995],[-0.41,44.995],[-0.41,44.96],[-0.446,44.96]] }
    ];
    const zoneLayers = {};

    // --- Rues "de base" (hardcod√©es) ---
    const BASE_STREETS = [
      {name:"Rue Nationale",       type:"mixte",        approxBoxes: 120, pts:[[44.993,-0.445],[44.998,-0.446],[45.002,-0.447]]},
      {name:"Route de Libourne",   type:"maisons",      approxBoxes: 60,  pts:[[44.993,-0.445],[44.990,-0.440],[44.985,-0.430]]},
      {name:"Rue de la Gare",      type:"appartements", approxBoxes: 80,  pts:[[44.995,-0.446],[44.996,-0.450],[44.997,-0.455]]},
      {name:"Avenue de l'Europe",  type:"appartements", approxBoxes: 100, pts:[[45.000,-0.440],[45.005,-0.435]]},
      {name:"Rue Dantagnan",       type:"maisons",      approxBoxes: 40,  pts:[[44.994,-0.448],[44.994,-0.452]]},
      {name:"Chemin Bois Milon",   type:"maisons",      approxBoxes: 35,  pts:[[44.985,-0.445],[44.980,-0.445]]},
      {name:"Rue Cousteau",        type:"mixte",        approxBoxes: 70,  pts:[[44.998,-0.442],[45.000,-0.438]]}
    ];

    // --- Supabase ---
    const SUPABASE_URL = "https://wqujtckrvdhrwknplumq.supabase.co"; 
    const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndxdWp0Y2tydmRocndrbnBsdW1xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxMjcwOTQsImV4cCI6MjA3ODcwMzA5NH0.btJD5-yD_zRJ9niEvwYEF46iB18OJo8nNXHRTbc8opE";
    let supabaseClient = null;

    // --- Poids pour le calcul des calories ---
    const NEGO_WEIGHTS = {
      "Alexis": 79,
      "Nicolas": 90,
      "Thibault": 72
      // Laurent : rien, il part :)
    };

    // --- √âtat global ---
    const state = {
      nego: "Alexis",
      streets: {},        // { name: { layer, zoneId, date, meta } }
      running: false,
      timerId: null,
      elapsedSec: 0,
      lastTick: null,
      gpsWatchId: null,
      gpsMarker: null,
      gpsLastPos: null,
      distanceMeters: 0
    };

    // --- DOM ---
    const selNego  = document.getElementById('negociateur');
    const btnGps   = document.getElementById('btnGps');
    const btnLoad  = document.getElementById('btnLoad');
    const btnStart = document.getElementById('btnStart');
    const btnSave  = document.getElementById('btnSave');
    const timerEl  = document.getElementById('timer');
    const coverageEl = document.getElementById('coverage');
    const flyersEl   = document.getElementById('flyers');
    const notesEl    = document.getElementById('notes');
    const infoEl     = document.getElementById('tourInfo');
    const loaderEl   = document.getElementById('loader');

    // --- Utils calcul temps & distance ---
    function formatDuration(sec) {
      const h = String(Math.floor(sec / 3600)).padStart(2, "0");
      const m = String(Math.floor((sec % 3600) / 60)).padStart(2, "0");
      const s = String(sec % 60).padStart(2, "0");
      return `${h}:${m}:${s}`;
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000; // m
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // --- Couleur rue selon date ---
    function getStreetColor(lastDate) {
      if (!lastDate) return "#bdc3c7"; // gris
      const days = (new Date() - new Date(lastDate)) / (1000 * 3600 * 24);
      if (days <= 20) return "#2ecc71";   // vert
      if (days <= 45) return "#f39c12";   // orange
      return "#e74c3c";                   // rouge
    }

    // --- Estimation temps par rue ---
    function estimateDurationMinutes(meta) {
      const boxes = meta?.approxBoxes || 0;
      let speed = 100; // bo√Ætes / heure par d√©faut
      if (meta?.type === "maisons") speed = 80;
      else if (meta?.type === "appartements") speed = 200;
      else if (meta?.type === "mixte") speed = 130;
      const hours = boxes / speed;
      return Math.round(hours * 60);
    }

    function streetTypeLabel(type) {
      if (type === "maisons") return "Maisons individuelles";
      if (type === "appartements") return "Immeubles / r√©sidences";
      if (type === "mixte") return "Mixte maisons / apparts";
      return "Non pr√©cis√©";
    }

    // --- Initialisation principale ---
    async function startApp() {
      try {
        if (typeof supabase !== "undefined") {
          supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        }

        // 1. Dessiner les secteurs
        ZONES.forEach(z => {
          const polyLatLng = z.poly.map(p => [p[1], p[0]]);
          const layer = L.polygon(polyLatLng, {
            color: z.color,
            fillOpacity: 0.05,
            weight: 1,
            dashArray: "4"
          }).addTo(map);
          zoneLayers[z.id] = layer;
        });

        // 2. R√©cup√©rer historique Supabase
        let history = {};
        if (supabaseClient) {
          try {
            const { data, error } = await supabaseClient.from('street_passages').select('*');
            if (!error && data) {
              data.forEach(d => {
                // On garde le dernier passage par rue
                const existing = history[d.street_name];
                if (!existing || new Date(d.passage_date) > new Date(existing.passage_date)) {
                  history[d.street_name] = d;
                }
              });
            }
          } catch (e) {
            console.warn("Supabase indisponible, mode hors-ligne pour l'historique.");
          }
        }

        // 3. Dessiner les rues de base
        BASE_STREETS.forEach(meta => {
          const h = history[meta.name] || null;
          drawStreet(meta, h);
        });

        // 4. Centrer sur le secteur du n√©go actuel
        focusOnNegotiator();
        updateUI();

        loaderEl.classList.add('hidden');
      } catch (err) {
        console.error(err);
        alert("Erreur critique lors du chargement : " + err.message);
        loaderEl.classList.add('hidden');
      }
    }

    // --- Dessin d'une rue ---
    function drawStreet(meta, histData) {
      const name = meta.name;
      const coords = meta.pts;
      const lastDate = histData ? histData.passage_date : null;
      const color = getStreetColor(lastDate);

      // D√©terminer zone par le centre
      let zoneId = "?";
      try {
        const mid = coords[Math.floor(coords.length / 2)];
        const pt = turf.point([mid[1], mid[0]]);
        const z = ZONES.find(z => turf.booleanPointInPolygon(pt, turf.polygon([z.poly])));
        if (z) zoneId = z.id;
      } catch (e) {}

      // Ligne cliquable (large, invisible)
      L.polyline(coords, { weight: 25, opacity: 0 }).addTo(map).on('click', (e) => {
        const safeName = name.replace(/'/g, "\\'");
        const mins = estimateDurationMinutes(meta);
        const minMins = Math.max(5, Math.round(mins * 0.8));
        const maxMins = Math.round(mins * 1.2);

        const content = `
          <div class="popup-content">
            <b>${name}</b><br>
            <small>Secteur : ${zoneId}</small><br>
            <small>Type : ${streetTypeLabel(meta.type)}</small><br>
            <small>Bo√Ætes estim√©es : ${meta.approxBoxes || "?"}</small><br>
            <small>Dur√©e estim√©e : ~${minMins}-${maxMins} min</small><br>
            <small>Dernier passage : ${lastDate || "Jamais"}</small>
            <button class="btn-popup" onclick="doStreet('${safeName}', ${zoneId})">‚úÖ Marquer comme fait</button>
            <button class="btn-popup secondary" onclick="addClientNote('${safeName}')">üìù Ajouter une note client</button>
          </div>
        `;
        // Zoom progressif sur la rue
        try {
          const bounds = L.latLngBounds(coords);
          map.flyToBounds(bounds, { padding: [40, 40], maxZoom: 18 });
        } catch(e) {}
        L.popup().setLatLng(e.latlng).setContent(content).openOn(map);
      });

      // Ligne visible (style selon type)
      let weight = 4;
      let dashArray = null;
      if (meta.type === "maisons") {
        dashArray = "4 4";
      } else if (meta.type === "appartements") {
        weight = 5;
      } else if (meta.type === "mixte") {
        dashArray = "1 8";
      }

      const layer = L.polyline(coords, {
        color: color,
        weight: weight,
        opacity: 0.9,
        dashArray: dashArray,
        interactive: false
      }).addTo(map);

      state.streets[name] = {
        layer,
        zoneId,
        date: lastDate,
        meta
      };
    }

    // --- Marquer une rue comme faite ---
    window.doStreet = async (name, zoneId) => {
      const today = new Date().toISOString().split('T')[0];
      const street = state.streets[name];
      if (street) {
        street.layer.setStyle({ color: "#2ecc71" });
        street.date = today;
      }
      map.closePopup();
      updateUI();

      if (supabaseClient) {
        try {
          await supabaseClient.from('street_passages').insert({
            street_name: name,
            passage_date: today,
            negociateur: state.nego,
            zone_id: zoneId
          });
        } catch (e) {
          console.warn("Erreur Supabase street_passages", e);
        }
      }
    };

    // --- Ajouter une note client (par rue) ---
    window.addClientNote = async (name) => {
      const note = prompt("Note client rencontr√©e dans cette rue :");
      if (!note || !note.trim()) return;

      if (supabaseClient) {
        try {
          await supabaseClient.from('client_notes').insert({
            negociateur: state.nego,
            street_name: name,
            note: note.trim()
          });
          alert("Note client enregistr√©e ‚úî");
        } catch (e) {
          console.warn("Erreur Supabase client_notes", e);
          alert("Erreur lors de l'enregistrement de la note.");
        }
      } else {
        alert("Note non enregistr√©e (Supabase indisponible).");
      }
    };

    // --- Centrage sur le secteur du n√©gociateur ---
    function focusOnNegotiator() {
      const z = ZONES.find(z => z.nego === state.nego);
      if (!z) return;
      const layer = zoneLayers[z.id];
      if (layer) {
        map.fitBounds(layer.getBounds(), { padding: [20, 20] });
      }
    }

    // --- Mise √† jour couverture & opacit√© ---
    function updateUI() {
      const myZone = ZONES.find(z => z.nego === state.nego)?.id;

      // Opacit√© des rues selon le n√©gociateur
      Object.values(state.streets).forEach(st => {
        const isActive = (st.zoneId === myZone);
        st.layer.setStyle({
          opacity: isActive ? 1 : 0.2,
          weight: isActive ? (st.meta.type === "appartements" ? 5 : 4) : 2
        });
      });

      // Couverture (rues de la zone)
      const streets = Object.values(state.streets).filter(s => s.zoneId === myZone);
      if (streets.length) {
        const done = streets.filter(s => s.date && (new Date() - new Date(s.date)) / 8.64e7 <= 20).length;
        const pct = Math.round((done / streets.length) * 100);
        coverageEl.innerText = `${pct}% (${done}/${streets.length})`;
      } else {
        coverageEl.innerText = "Hors zone / 0 rue";
      }

      // Info tourn√©e
      const kms = state.distanceMeters / 1000;
      infoEl.textContent = kms > 0
        ? `Distance estim√©e : ${kms.toFixed(2)} km`
        : "";
    }

    // --- Timer tourn√©e ---
    function startTimer() {
      state.lastTick = Date.now();
      state.timerId = setInterval(() => {
        const now = Date.now();
        const delta = Math.floor((now - state.lastTick) / 1000);
        if (delta > 0) {
          state.elapsedSec += delta;
          state.lastTick = now;
          timerEl.textContent = formatDuration(state.elapsedSec);
        }
      }, 1000);
    }

    function stopTimer() {
      if (state.timerId) {
        clearInterval(state.timerId);
        state.timerId = null;
      }
    }

    function toggleTour() {
      if (!state.running) {
        // D√©marre ou reprend
        state.running = true;
        state.lastTick = Date.now();
        startTimer();
        btnStart.textContent = "‚è∏ Pause";
        btnStart.classList.remove('primary');
        btnStart.classList.add('accent');
        btnSave.disabled = true;
        btnSave.style.background = "#eee";
        btnSave.style.color = "#555";
      } else {
        // Pause
        state.running = false;
        stopTimer();
        btnStart.textContent = "‚ñ∂ Reprendre";
        btnStart.classList.add('primary');
        btnStart.classList.remove('accent');
        btnSave.disabled = false;
        btnSave.style.background = "#2ecc71";
        btnSave.style.color = "#fff";
      }
    }

    async function saveTour() {
      // Fin de tourn√©e : on stoppe le timer si encore en marche
      if (state.running) {
        state.running = false;
        stopTimer();
      }

      const durationSec = state.elapsedSec;
      const distanceKm = state.distanceMeters / 1000;
      const weight = NEGO_WEIGHTS[state.nego] || 75;
      const calories = Math.round(distanceKm * weight * 0.9); // mod√®le simple marche √† pied

      const myZone = ZONES.find(z => z.nego === state.nego);
      const secteurId = myZone ? myZone.id : null;

      // Enregistrement Supabase
      if (supabaseClient) {
        try {
          await supabaseClient.from('tours').insert({
            negociateur: state.nego,
            date: new Date().toISOString().slice(0,10),
            secteur_id: secteurId,
            flyers: parseInt(flyersEl.value) || 0,
            notes: (notesEl.value || "").trim(),
            duration_sec: durationSec,
            distance_m: Math.round(state.distanceMeters),
            calories_kcal: calories
          });
        } catch (e) {
          console.warn("Erreur Supabase tours", e);
          alert("Erreur lors de l'enregistrement de la tourn√©e.");
          return;
        }
      }

      alert(
        "Tourn√©e enregistr√©e ‚úÖ\n\n" +
        "Dur√©e : " + formatDuration(durationSec) + "\n" +
        "Distance estim√©e : " + distanceKm.toFixed(2) + " km\n" +
        "Calories estim√©es : " + calories + " kcal"
      );

      // Reset des champs pour la prochaine tourn√©e
      state.elapsedSec = 0;
      timerEl.textContent = "00:00:00";
      flyersEl.value = "";
      notesEl.value  = "";
      state.distanceMeters = 0;
      infoEl.textContent = "";
      btnSave.disabled = true;
      btnSave.style.background = "#eee";
      btnSave.style.color = "#555";
      btnStart.textContent = "‚ñ∂ D√©marrer";
      btnStart.classList.add('primary');
      btnStart.classList.remove('accent');
    }

    // --- GPS ---
    function toggleGPS() {
      if (state.gpsWatchId) {
        // Stop
        navigator.geolocation.clearWatch(state.gpsWatchId);
        state.gpsWatchId = null;
        if (state.gpsMarker) {
          map.removeLayer(state.gpsMarker);
          state.gpsMarker = null;
        }
        state.gpsLastPos = null;
        btnGps.textContent = "üìç GPS";
        btnGps.classList.remove('primary');
        btnGps.classList.add('accent');
      } else {
        if (!navigator.geolocation) {
          alert("GPS non support√© sur ce navigateur.");
          return;
        }
        state.distanceMeters = 0;
        state.gpsLastPos = null;

        btnGps.textContent = "üõë GPS";
        btnGps.classList.add('primary');
        btnGps.classList.remove('accent');

        state.gpsWatchId = navigator.geolocation.watchPosition(pos => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          const latlng = [lat, lng];

          if (!state.gpsMarker) {
            state.gpsMarker = L.circleMarker(latlng, {
              radius: 7,
              color: "#1976d2",
              weight: 2,
              fillColor: "#2196f3",
              fillOpacity: 0.9
            }).addTo(map);
            // On recentre une premi√®re fois
            map.setView(latlng, 17);
          } else {
            state.gpsMarker.setLatLng(latlng);
          }

          if (state.gpsLastPos && state.running) {
            const d = haversineMeters(state.gpsLastPos[0], state.gpsLastPos[1], lat, lng);
            // filtre les sauts GPS absurdes
            if (d < 200) {
              state.distanceMeters += d;
              updateUI();
            }
          }
          state.gpsLastPos = latlng;
        }, err => {
          console.error("Erreur GPS", err);
          alert("Impossible d'obtenir la position GPS.");
          if (state.gpsWatchId) {
            navigator.geolocation.clearWatch(state.gpsWatchId);
            state.gpsWatchId = null;
          }
          btnGps.textContent = "üìç GPS";
          btnGps.classList.remove('primary');
          btnGps.classList.add('accent');
        }, {
          enableHighAccuracy: true,
          maximumAge: 15000,
          timeout: 20000
        });
      }
    }

    // --- Chargement Overpass (rues manquantes) ---
    async function loadMoreStreets() {
      const btn = btnLoad;
      btn.innerText = "‚è≥";
      btn.disabled = true;
      try {
        const q = `
          [out:json][timeout:15];
          (
            way["highway"~"residential|unclassified|living_street|tertiary"]["name"](44.98,-0.46,45.01,-0.43);
          );
          out geom;
        `;
        const res = await fetch("https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(q));
        const data = await res.json();
        let count = 0;
        if (data.elements) {
          data.elements.forEach(el => {
            if (el.tags && el.tags.name && el.geometry) {
              const name = el.tags.name;
              if (!state.streets[name]) {
                const pts = el.geometry.map(p => [p.lat, p.lon]);
                const meta = { name, type: "mixte", approxBoxes: 80, pts };
                drawStreet(meta, null);
                count++;
              }
            }
          });
        }
        alert(count + " nouvelles rues ajout√©es.");
        updateUI();
      } catch (e) {
        console.error(e);
        alert("Erreur lors du chargement des rues suppl√©mentaires.");
      }
      btn.innerText = "‚ûï Rues";
      btn.disabled = false;
    }

    // --- √âcouteurs ---
    selNego.addEventListener('change', (e) => {
      state.nego = e.target.value;
      focusOnNegotiator();
      updateUI();
    });

    btnGps.addEventListener('click', toggleGPS);
    btnLoad.addEventListener('click', loadMoreStreets);
    btnStart.addEventListener('click', toggleTour);
    btnSave.addEventListener('click', saveTour);

    // --- Lancement ---
    startApp();
  </script>
</body>
</html>
